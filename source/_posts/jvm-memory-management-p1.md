---
title: JVM内存管理(一)
date: 2019-12-08 19:44:01
updated:
tags: JVM
categories: 技术
thumbnail: taylor.jpg
---

## 前言

该系列源自一个月前的技术分享讲稿，稍作整理后记录于此。系列分为3篇，分别是：内存分配、内存回收以及内存管理技术在HotSpot上的具体实现。本篇先来聊一聊JVM中内存的分配。

## 从虚拟内存说起

说起内存，可能大家的第一反映是这个：

{% asset_img memory.jpg "内存条" %}

从硬件的角度来看，内存就是一块有固定容量的存储体,与该硬件直接打交道的是我们的操作系统。我们知道在操作系统中，进程都是共享CPU和内存资源的。现代操作系统为了更有效的管理内存,广泛使用了虚拟内存技术。

在提出虚拟内存之前，内存是这样访问的: 

{% asset_img directaccess.png "直接访问内存" %}

我们把一块大的内存分成很多一样大的单元，给他们依次编上号，也就是内存的物理地址。进程要访问哪个单元的数据时候，就要指明物理地址。

各个进程直接访问物理地址，这就有很大的随意性，安全性得不到保障：你在内存上存得数据可能随时被别人改写了。写个程序还要搞清楚内存硬件得结构，十分不便。于是虚拟内存技术应运而生：既然各个进程直接访问物理内存不好，那就让操作系统接管物理内存的访问，而进程访问时，先告诉操作系统一个地址，然后由操作系统代为访问。与物理地址相对应，进程所用的地址就是逻辑地址。

我们可以看着张示意图，cpu在执行某个进程的代码，当进程访问一个内存地址时，这个地址其实是经过了内存管理单元的转换，再变成物理地址。

{% asset_img indirectaccess.png "间接访问内存" %}

有了这一层转换，那这样我就可以做些有趣的事情。

比如我们内存条是1G的, 这时某个进程需要4G的内存,那么操作系统可以为其映射出4G的空间。具体是这样：虚拟内存将主存看成是磁盘的高速缓存，应用在未运行之前,只是存储在磁盘上二进制文件。当你双击鼠标启动一个应用时，操作系统就为这个应创建了一个进程。这时并不需要把应用的全部代码和数据都加载进内存，而是用到哪些加载哪些。虽然你的进程需要访问4G的空间，但并不是每时每刻都需要用到全部的数据。所以咱们就拆东墙补西墙：内存空间不够时，那就把暂时不用的换出到磁盘，腾出新的空间来载入新的数据。空间不够，时间来凑：通过用时间换空间的方式达到放大内存的效果。

因此，虚拟内存可以为每个进程提供了一个假象：每个进程都在独占地使用主存,每个进程看到的内存都是一样的,这称之为虚拟地址空间。这样，操作系统就可以为每个进程提供独立的地址空间,简化了内存管理机制。简单点来看就是每个进程都认为自己独占该主存。

{% asset_img vspace.png "地址空间隔离" %}

就像一栋楼被分成许多个房间,每个房间都是独立的，每个户主拿到一个房间，都可以从零开始自助装修。另外,在未征得其他户主的同意之前,你是无法进入其他房间的，这样大大增加了安全性。

现在我们明白在操作系统中所谈的内存其实是虚拟内存。那么虚拟地址空间的布局是如何的呢? 以Linux系统为例，来看一下它的进程空间地址的布局。

## JVM的内存结构

现在来到了进程这一层级。我们知道,每个JVM都运行在一个单独的进程当中，JVM本质上也是一个程序，只不过它又有着类似操作系统的特性，有着自己的内存模型和内存结构。当一个JVM实例开始运行时，此时在Linux进程中,其内存布局如图中所示。

{% asset_img pspace.png "Linux进程地址空间" %}

从下到上，内存地址由低到高。内核空间在高位，这里映射的是操作系统内核的代码。用户空间在低位，我们看到，从低到高依次为代码数据区、堆区、共享库和用户栈。

JVM进程对内存空间进行了进一步划分。

{% asset_img jvmpspace.png "JVM进程的地址空间" %}

总的来说，主要就是栈和堆两个部分。基于进程栈，JVM实现了自己的方法执行栈而对于进程的堆，JVM把它划分为：方法区和Java堆。方法区就是Java程序的代码数据区，Java堆才是Java程序真正使用的堆区。右边这一块就是JVM的运行时数据区，也就是它的内存结构。下面这张图展示了它的详细结构。

{% asset_img rtda.jpg "JVM运行时数据区"%}

主要分为这几块：虚拟机栈、本地方法栈、PC寄存器以及方法区和Java堆。其中右边两块是JVM中所有线程所共享的，而左边则是各个线程私有的。也就是每个线程都有自己的一套栈和PC寄存器。下面一一介绍。

### PC寄存器

PC寄存器就跟CPU中的PC寄存器类似，用来存储下一条指令的地址。只不过这里的指令是字节码。我们知道Java源码编译成字节码后再交由JVM执行的。

### JVM栈

Java虚拟机栈，这是用来执行Java方法的。每调用一个方法，一个对应栈帧就会被创建并入栈。一个方法的执行过程就是其栈帧从入栈到出栈的过程。栈帧中主要存储：局部变量表、操作数栈、动态链接以及方法出口等信息。局部变量表存放方法参数和方法内定义的局部变量；操作数栈用于存放方法体中指令的操作数；每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用；方法返回地址保证方法正常返回时能够继续正常执行。

{% asset_img jvmstack.png "JVM栈" %}

虚拟机栈也是线程独有的，每创建一个线程，其相应的栈也会被创建；相应的，一个线程在销毁后，其对应的栈也会被销毁。

### 本地方法栈

除了虚拟机栈，还有一个本地方法栈。这个栈是用来执行非Java方法的，主要是C或者C++写成的方法。大家可能觉得奇怪，你一个JVM怎么还要执行非Java方法呢？这主要是因为Java运行于虚拟机之上，与外界的交互没有那么方便。比如操纵JVM线程，因为JVM线程也是对操作系统线程的映射，Java不好直接和操作系统交流那就只有求助于本地方法了。

### 方法区

方法区就是Java程序的代码区，这里主要存放类的信息。在方法区中由一块很重要的区域便是运行时常量池。运行时常量池主要存放的字面量和符号引用。符号引用简单来说就像门牌号一样，用来标识类、以及类中的字段、方法。

什么是运行时常量池呢？首先我们要搞清楚什么是常量池。常量池是Class文件的重要组成部分。
我们知道一个类对应一个Class文件，这个文件就是对类的描述，比如这个类的类名、有哪些字段、有什么方法等等。而像类名、字段名、方法名这样的信息就存储在常量池中。

看下面一个例子：我们定义一个Hello类，它有两个方法：foo和bar，其中foo调用了bar。我们使用javac进行编译并使用javap反编译Class文件。

{% asset_img hello.png "反编译class文件" %}

这里是class文件中存储的foo的定义，当然这个结果经过了javap的重新编排便于阅读。我们关注foo的code属性部分，它包含3条字节码。其中第二条是对bar的调用。可以看到invokevirtual指令的操作数是一个编号，指向就是常量池。常量池就像class文件中的仓库一样，class文件的其他项目都会引用它的内容。而在class文件定义的类被加载后，其中的常量池字段被存储在运行时常量池中。方法区是所有线程所共享的。

### Java堆

这里就是对象所在的地方。根据JVM规范，对象和数组都在堆上分配。

Java的堆区和进程上的堆却又很大的区别:使用进程上的堆，比如在调用C程序的malloc函数时，会引起一次系统级的调用；在使用free函数释放内存时,同样也会引起一次系统级的调用,但是JVM中堆区并非如此：JVM一次性向系统申请一块连续的内存区域,作为Java程序的堆。当Java程序使用new申请内存时，JVM会根据需要在这段内存区域中为其分配，而不需要一次系统级别的调用。相比系统级别的调用，JVM实现内存管理成本更低。

Java堆是进行垃圾收集的主要区域，详见后续文章。

## 对象的创建

下面说说对象的创建，在简简单单的一个关键字new背后发生了什么呢？主要分为以下阶段：

1.	类加载检查
2.	内存分配
3.	内存空间初始化
4.	对象信息设置
5.	构造方法执行

当你要new一个对象时，首先会检查这个类有没有被加载。具体来说根据指令的参数检查能否在常量池定位到这个类的符号引用。如果发现这个类还没有被加载，则进行类加载过程。

接下来为对象进行内存的分配，即划分出一块大小已知的连续内存。这里分为两种情况：一是，当空闲内存是连续规整的，那么我可以设置一个指针，指针的一边是使用中的内存，另一边是空闲内存。分配时把指针向空闲一边移动一段与对象大小相等的距离即可。这种分配方式叫做“指针碰撞”。二是，假如内存不是连续规整的，那么虚拟机就要维护一个列表，记录哪些内存区域是可用的，分配时从列表中选取合适的内存区域进行分配。这叫做“空闲列表”。我们可以注意到，连续规整的内存可以让内存的分配更加简单快速。

接下来将分配到的内存空间全部初始化为零，并设置对象头中的信息，比如：对象类型指针、hashCode等。最后执行为对象的构造方法，进行用户自定义的初始化。至此你们要的对象在堆中诞生了。

## 后记

本篇从自底向上的视角简要介绍了JVM的内存布局及分配，下一篇咱们继续聊聊JVM内存管理中的内存回收技术。