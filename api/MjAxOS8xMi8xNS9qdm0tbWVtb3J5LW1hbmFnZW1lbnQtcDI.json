{"title":"JVM内存管理(二)","date":"2019-12-15T13:54:04.000Z","thumbnail":"/2019/12/15/jvm-memory-management-p2/troye.jpg","link":"2019/12/15/jvm-memory-management-p2","tags":["JVM"],"categories":["技术"],"updated":"2021-05-10T21:08:59.237Z","content":"<h2 id=\"前言\">前言<a href=\"2019/12/15/jvm-memory-management-p2#前言\"></a></h2><p>这一篇来聊一聊内存的回收，即垃圾收集(Garbage Collection)。GC所要解决的主要是以下两个问题：</p>\n<ol>\n<li>哪些内存需要回收？</li>\n<li>怎么回收？</li>\n</ol>\n<p>下面就以这两个问题为主要线索，介绍垃圾收集相关技术。</p>\n<h2 id=\"哪些内存需要回收？\">哪些内存需要回收？<a href=\"2019/12/15/jvm-memory-management-p2#哪些内存需要回收？\"></a></h2><p>我们先回顾一下JVM运行时数据区域，依照是否在线程间共享，可以将其划分为两类：</p>\n<ol>\n<li>独占：PC、虚拟机栈以及本地方法栈</li>\n<li>共享：方法区（运行时常量池）、Java堆（对象及数组在此创建）</li>\n</ol>\n<p>我们不难发现，由线程独占的区域不需要内存回收机制：从时间上来说，它们与线程“同生共死”;从空间上来看，PC所占空间大小是恒定不变的。而栈则由于其自身的LIFO特性，也无需额外的内存清理工作。</p>\n<p>而线程共享的区域，包括方法区和Java堆则是GC所要考虑的。之前说过，Java堆是垃圾收集器的主要战场，在堆中创建对象十分频繁，名副其实的垃圾堆。那么我们如何识别方法区和堆上的所谓垃圾呢？</p>\n<p>所谓垃圾就是没用的东西。在Java中，数据都是以对象形式组织起来的，垃圾即是无法被访问到的对象。所以说判断一个对象是不是垃圾，可以看它被引用的数量。哪怕在一处被引用，它也是不可回收的。很自然地，我们可以为每一个对象设置一个计数器，每被引用一次计数器加一，反之减一。当引用数为0的时候，说明没有任何途径可以访问到这个对象，此时可以回收该对象。这就是引用计数法。</p>\n<p>但这个方法虽然简单，可是却有一些问题。看下面一段代码：</p>\n<img src=\"/2019/12/15/jvm-memory-management-p2/circular.png\" title=\"循环引用示例\" class=\"article-img\">\n\n<p>首先，两个类A和B，其中A中有一个B类型的字段bRef，或者说可以指向B类型的引用；同样地，B中有一个A类型的字段aRef。接下来我们实例化两个对象a、b，并且将实例a的bRef指向实例b，而将实例b的aRef指向实例a。随后将a、b均设为null。现在，我们再也无法从外部访问到类型A、B的两个实例了，按说这两个实例都可以被标记为垃圾被回收。但按照引用计数法，由于它们俩各自持有对对方的引用，因此他们的引用计数均为1，因此无法被回收。这就是引用计数法无法解决的“循环引用问题”。</p>\n<p>看来得想想别的办法。问题出在哪里呢？我们发现引用计数法对所有的引用都一视同仁，但好像并不是所有的引用都有效。那么什么样的引用才是有效的引用呢？我们定义一组这样的活跃引用：</p>\n<ol>\n<li>栈（栈帧中的本地变量表）中的引用</li>\n<li>方法区中引用</li>\n</ol>\n<p>我们可以发现它们一个共同的特点：在Java堆的外面。由这样一组引用所直接指向的对象所组成的集合就叫做GCRoots。简而言之，GCRoot就是在堆外被直接引用的对象。</p>\n\n\n<p>以GCRoots为起点，继续寻找它们所引用的对象，以此类推，这样顺着引用链搜索便可以找到堆中其他的可用对象，这叫做root tracing。而剩下的对象就是不可用的，可以被回收。</p>\n<p>以上所述为Java堆中对象的标记，那么方法区又是怎样的呢？方法区里主要存储的是类型信息。而一个类想要被回收，则它必须满足：</p>\n<ol>\n<li>该类的所有实例都已被回收</li>\n<li>加载该类的ClassLoader已被回收</li>\n<li>该类对应的Class对象在任何地方被引用，且在任何地方都无法通过反射访问该类的方法。</li>\n</ol>\n<p>此时，一个类可以被回收。可以说回收条件是相当苛刻的。所以方法区的回收效益并不高。其实JVM规范并没有对方法区的垃圾收集行为做强制性规定，虚拟机实现甚至可以选择在方法区内不进行垃圾收集。但是，作为一款优秀的JVM方法区的回收也是必须的。</p>\n<h2 id=\"如何回收？\">如何回收？<a href=\"2019/12/15/jvm-memory-management-p2#如何回收？\"></a></h2><p>已经知道回收哪些内存区域了，通过什么方式回收呢？基本思想主要有以下三种：</p>\n<ol>\n<li>标记-清除算法</li>\n<li>标记-整理算法</li>\n<li>复制算法</li>\n</ol>\n<h3 id=\"标记清除算法\">标记清除算法<a href=\"2019/12/15/jvm-memory-management-p2#标记清除算法\"></a></h3><p>标记-清除算法分为两个阶段：第一个阶段标记出所有需要回收的对象，具体做法在之前已经讲到。第二阶段，回收被标记对象的内存区域。</p>\n<img src=\"/2019/12/15/jvm-memory-management-p2/mark-sweep.png\" title=\"标记清除算法\" class=\"article-img\">\n\n<p>这个算法简洁明了，但缺点也很明显：经过回收之后的内存区域碎片化严重，存在大量离散的空间。这很不利于后续的内存分配。</p>\n<h3 id=\"标记整理算法\">标记整理算法<a href=\"2019/12/15/jvm-memory-management-p2#标记整理算法\"></a></h3><p>标记-整理算法在标记之后会将存活的对象向一端移动，然后直接清除边界以外的空间。这样做的好处很明显：GC后的内存是连续规整的，有利于后续的内存分配。</p>\n<img src=\"/2019/12/15/jvm-memory-management-p2/mark-compact.png\" title=\"标记整理算法\" class=\"article-img\">\n\n<h3 id=\"复制算法\">复制算法<a href=\"2019/12/15/jvm-memory-management-p2#复制算法\"></a></h3><p>接下来是复制算法。使用复制算法时，需要将内存等分为两个区域。每次只在其中一个区域内分配。当该空间用完时，先标记对象，然后将存活对象依次复制到另一个区域里，形成连续的存活对象区域。后续的内存分配只在该区域内进行，直至空间用完，触发下一次GC,如此周而复始。</p>\n<img src=\"/2019/12/15/jvm-memory-management-p2/copy.png\" title=\"复制算法\" class=\"article-img\">\n\n<p>相较标记-清除算法，复制算法的一个显著优点是回收后的内存空间十分规整，无论是在使用的空间还是未使用的空间都是连续分布，这样后续的内存分配也更加快速。当然缺点也很明显：空间利用率不高。</p>\n<h3 id=\"分代收集\">分代收集<a href=\"2019/12/15/jvm-memory-management-p2#分代收集\"></a></h3><p>在介绍完以上三种基本的垃圾收集思路后，再来看一看分代收集算法。之所以提出分代收集，一是上述的思想每一种都不能称之为完美，各自的优点和局限都比较突出。二是经过研究发现，若以存活时间为标准将对象分代，那么不同代际的对象在存活率上确实有显著差异。比如：IBM的研究表明，新生代中的对象98%都是“朝生夕死“，也就是说存活率很低。</p>\n<img src=\"/2019/12/15/jvm-memory-management-p2/dieyoung.png\" title=\"朝生夕死的对象\" class=\"article-img\">\n\n<p>结合以上两点，我们可以在不同年龄的对象上使用不同的垃圾收集算法，扬长避短，获得最好的收集效果。</p>\n<p>分代算法一般根据对象存活的时间，即所经历的GC轮次，将对象分为新生代和老年代两种。因此对于新生代可以使用复制算法：因为留下来的并不多，所以复制的效率并不会太差。而成长为老年代的对象一般来说存活率都比较高，因此可以使用标记-整理算法：因为大部分对象都会存活下来，每次GC后，存活对象间不会出现太多的空闲区域需要压缩整理，因此整理所花费的代价也不会太高。</p>\n<h2 id=\"后记\">后记<a href=\"2019/12/15/jvm-memory-management-p2#后记\"></a></h2><p>方法论讲完了，在本系列的最后一篇，我们将来看一看HotSpot虚拟机如何完成高效实现。</p>\n","prev":{"title":"JVM内存管理(三)","link":"2020/01/22/jvm-memory-management-p3"},"next":{"title":"JVM内存管理(一)","link":"2019/12/08/jvm-memory-management-p1"},"plink":"http://xray.kim/2019/12/15/jvm-memory-management-p2/","toc":[{"title":"前言","id":"前言","index":"1"},{"title":"哪些内存需要回收？","id":"哪些内存需要回收？","index":"2"},{"title":"如何回收？","id":"如何回收？","index":"3","children":[{"title":"标记清除算法","id":"标记清除算法","index":"3.1"},{"title":"标记整理算法","id":"标记整理算法","index":"3.2"},{"title":"复制算法","id":"复制算法","index":"3.3"},{"title":"分代收集","id":"分代收集","index":"3.4"}]},{"title":"后记","id":"后记","index":"4"}],"copyright":{"author":"Ray","link":"<a href=\"http://xray.kim/2019/12/15/jvm-memory-management-p2/\" title=\"JVM内存管理(二)\">http://xray.kim/2019/12/15/jvm-memory-management-p2/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}