[{"title":"JVM内存管理(三)","date":"2020-01-22T08:57:00.000Z","updated":"2021-05-10T21:08:59.241Z","content":"前言这是该系列的最后一篇了。本打算和前两篇一样周更，无奈由于各种事由拖到了寒假。博客这件事，还须坚持，坚持，再坚持！\n本文主要结合HotSpot这款流行的JVM实现，主要从分代收集、根枚举和垃圾收集器几个方面做简要介绍。\n分代收集在HotSpot中，将堆内存分为新生代和老年代。\n\n\n其中新生代区域被进一步划分为一块Eden区和两块Survivor区，它们之间的比例为8：1：1。所以我们看，这种设计的空间利用率还是比较高的，只有10%的空间空闲。GC时，使用复制算法把Eden和Servivor中还存活的对象复制到另一个Survivor区域中，最后对清理Eden和刚才Survivor中的空间。对于老年代，使用的是标记-整理算法。\n在HotSpot中，对象优先在Eden分配，当Eden区没有足够的空间进行分配时，将触发一次minor GC，也就是对新生代进行垃圾收集。当然，并不是所有的对象都一定分配在Eden，对于大对象，比如很长的数组或字符串，它们会直接被分配到老年代。这是因为新生代采用复制算法，进行大对象的复制代价很大。具体多大算大，这个阈值可以通过参数进行设置。\n新生代每经过一次minor GC并存活下来，年龄便会加一，当它达到一定年龄之后，默认为15岁，便可以晋升为老年代了。当然并不是一定得达到年龄要求后才能进入老年代，虚拟机对某些场景进行了一些优化。比如：在survivor中处于某个年龄的所有对象的总大小超过了survivor空间的一半，那么大于或等于这个年龄的对象可以直接进入老年代。\n与minor GC相对的是full GC, 比如当老年代空间告急时就会触发一次full GC，即在整个堆上进行一次垃圾收集。\n根枚举前面我们说到，任何垃圾收集算法在第一阶段要做的都是对对象进行标记。进行可达性分析的时候，就要从GCRoots开始进行root tracing。\n我们知道GCRoots的定义了：被全局性引用（常量或静态属性）或执行上下文（如栈帧中本地变量）所引用的对象。但如何才能找到这些活跃引用呢，即如何完成根枚举（root enumeration）呢？要知道搜寻活跃引用的范围并不小，而且在进行根节点枚举时有一个Stop The World过程，也就是再GC进行枚举的时候，其他用户线程都要停下来。我们想象一下，垃圾收集其实就像打扫房间一样，在你妈妈打扫房间的时候，你还会继续往地上扔垃圾吗？你是不是还得把脚抬一抬？Stop The World听起来很酷，但我们都不喜欢。那么如何能够高效快速地完成根节点枚举呢？\n以栈上引用的查找为例，主要有两种不同的实现方式。\n首先引入保守式GC的概念。在这种实现方式中，JVM不会记录栈帧内的数据类型，因此也无法区分内存里某个位置上的数据到底应该解读为引用类型还是其他类型。在进行GC的时候，JVM开始从一些已知位置（例如说JVM栈）开始扫描内存，扫描的时候每看到一个数字就看看它“像不像是一个指向GC堆中的指针”。这里会涉及上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针），之类的。然后这样递归地扫描出去。\n保守式GC的缺点很明显：由于它找到的都是疑似引用，那么真正的引用固然不会错过，但一些假引用也被纳入GCRoots，所以会造成垃圾收集的不充分。\n与保守式相对的是准确式GC，这也是主流JVM，包括HotSpot所采用的方式。采用准确式GC就是说JVM准确地知道栈帧内各变量中哪些是引用，这样在查找GCRoots时就不用遍历栈上的每个变量了。如何做到这一点呢？以空间换时间。主流的做法是使用额外的数据结构从外部记录下类型信息。在HotSpot中，这个数据结构叫做OopMap。\nOop指的是Ordinary Object Pointer：普通对象指针。OopMap的作用就是记录栈上那些地方是引用。实现这样的功能，需要解释器和JIT编译器的共同支持：它们知道变量确切的地址，由它们生成足够的元数据再GC的时候使用。我们知道程序运行过程中，引用关系一直在变化，那我们要一直跟着生成OopMap来追踪引用的位置信息吗？即：何时生成OopMap呢？\n首先，在类加载过程中，对象的类型信息里便会生成自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的。\n而为了记录其他位置，比如栈上的引用，HotSpot会在某些指令流的特定位置记录下OopMap，指示执行到该方法的某条指令的时候，栈上哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些特定的位置主要在：\n\n循环的末尾\n方法临返回前 / 调用方法的call指令后\n可能抛异常的位置\n\n这种位置被称为“安全点”（safepoint）。\n之所以要选择一些特定的位置来记录OopMap，是因为如果对每条指令（的位置）都记录OopMap的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量，但仍然能达到区分引用的目的。因此，HotSpot中GC不是在任意位置都可以进入，而只能在safepoint处进入。\n那么在GC发生时如何让所有的线程（不包括执行JNI调用的线程）都能到达安全点呢？有两种方法：一种是抢先式中断，另一种是主动式中断。抢先式中断是指GC时，首先把所有的线程都中断，如果被中断的线程不在安全点上，则恢复该线程让它继续跑到安全点上。主动式中断是指GC时不中断线程，只设置一个中断标志，各个线程在执行时主动轮询这个标志，当标志为真时就主动中断挂起。何时轮询呢？一般是在安全点处以及创建对象分配内存时。现在一般都采用主动式中断方案。\n正在运行的线程可以跑到安全点，那没有正在执行的线程怎么办呢？比如处于Blocked状态的线程，它是不可能自己主动到达安全点的。为此我们引入安全域（safe region）的概念。安全区域是指引用关系不会发生变化的代码区域。比如线程被挂起后就不会改变引用关系。在线程执行到安全域中的代码之后，首先会标识自己已经进入了安全域。这样gc时便不用关心那些safe region状态的线程了；而当线程要离开安全域时，首先检查根枚举是否完成，如果是则可以安全离开，否则等待离开信号。\n以上我们所说的都是Java线程，对于Java线程中的JNI方法，它们既不是由JVM里的解释器执行的，也不是由JVM的JIT编译器生成的，所以会缺少OopMap信息。那么GC碰到这样的栈帧该如何维持准确性呢？HotSpot的解决方法是：所有经过JNI调用边界（调用JNI方法传入的参数、从JNI方法传回的返回值）的引用都必须用“句柄”（handle）包装起来。JNI需要调用Java API的时候也必须自己用句柄包装指针。在这种实现中，JNI方法里写的“jobject”实际上不是直接指向对象的指针，而是先指向一个句柄，通过句柄才能间接访问到对象。这样在扫描到JNI方法的时候就不需要扫描它的栈帧了——只要扫描句柄表就可以得到所有从JNI方法能访问到的GC堆里的对象。但这也就意味着调用JNI方法会有句柄的包装/拆包装的开销，是导致JNI方法的调用比较慢的原因之一。\n但这还不够。前面说到，GC分为MinorGC和FullGC。在进行FullGC的时候，这样好像没问题。但是MinorGC的时候就不一定了。比如说，枚举根节点时，根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代，所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？\nHotSpot使用RememberedSet 用于处理这类问题：仍然是拿空间换时间的办法。事实上，对于位于不同年代对象之间的引用关系，虚拟机会在程序运行过程中给记录下来。对应上面所举的例子，“老年代对象引用新生代对象”这种关系，会在引用关系发生时，在新生代边上专门开辟一块空间记录下来，这就是 RememberedSet 。所以“新生代的 GC Roots ” + “ RememberedSet 存储的内容”，才是Minor GC时真正的 搜索根节点。后面说的G1收集器也用到了这种数据结构。\n垃圾收集器下面就来简单介绍一下HotSpot的几款具有代表性的垃圾收集器：Serial、CMS以及G1。\n\n\nSerial收集器是最基本、也是发展历史最悠久的收集器。它使用的是复制算法，用于新生代。是一个单线程的收集器。它在收集垃圾时，必须暂停其他所有线程，Stop The World，直到垃圾收集结束。以下是它的运行示意图。可以看到它是完全单线程工作的。\n\n\nCMS，Concurrent Mark Sweep，并发标记-清除，用于老年代收集。它以低停顿为目标，它的优势在于标记与清除阶段可以并发进行。主要阶段为：\n\n初始标记\n并发标记\n重新标记\n并发清除\n\n其中，初始标记以及并发标记这两个阶段仍然需要stw。初始标记指是标记与gcroots直接关联的对象，时间很短。完全的Root tracing在并发标记阶段进行。由于在这个阶段由于用户程序也在运行因此可能会改变之前的标记，这时还需要重新标记来进行修正，这个阶段时间会比初始标记稍长，但远比并发标记短。最后是并发清除过程。\n\n\n从图中可以看出，整个GC过程中耗时最长的root tracing和清除过程都可以并发进行。因此CMS可以提供较低的gc停顿。\n最后介绍一下G1，Garbage Fisrt，这是一款能够独当一面的收集器，它既可以用于新生代也可以用于老年代。\n\n\n主要分为如下几个阶段：\n\n初始标记\n并发标记\n最终标记\n筛选回收\n\n从流程上来，它和CMS很相似。G1采用了化整为零的思想，把一块大的内存划分成很多个域（ Region ），以域为单位进行gc。\n\n\n可以看到，虽然还保留了新生代和老年代的概念，但它们不再是那样泾渭分明，物理隔离的了，都是region的集合。\nG1能够提供可预测的停顿，因为它有计划地避免在Java堆中进行全域的垃圾收集。G1跟踪各个Region里垃圾堆的价值大小，即回收所获得的空间大小以及回收所需时间的经验值，并在后台维护一个优先列表，每次根据允许的收集时间优先回收价值最大的region，从而达到尽可能高的gc效率。只对一个region进行回收，听起来不错。但问题是，各个region的对象间难免存在引用关系。那么在进行标记时岂不是还要扫描整个堆吗？为了达到可以以 Region 为单位进行垃圾回收的目的，G1 收集器也使用了 RememberedSet 的数据结构，在各个 Region 上记录自己的对象被外面对象引用的情况。gc时，以gcroot连同remembered set为起点开始标记。\n后记JVM内存管理系列暂时告一段落。希望新的一年里能保持稳定的内容输出。2020，奥利给！\n","thumbnail":"/2020/01/22/jvm-memory-management-p3/chateau.jpg","plink":"http://xray.kim/2020/01/22/jvm-memory-management-p3/"},{"title":"JVM内存管理(二)","date":"2019-12-15T13:54:04.000Z","updated":"2021-05-10T21:08:59.237Z","content":"前言这一篇来聊一聊内存的回收，即垃圾收集(Garbage Collection)。GC所要解决的主要是以下两个问题：\n\n哪些内存需要回收？\n怎么回收？\n\n下面就以这两个问题为主要线索，介绍垃圾收集相关技术。\n哪些内存需要回收？我们先回顾一下JVM运行时数据区域，依照是否在线程间共享，可以将其划分为两类：\n\n独占：PC、虚拟机栈以及本地方法栈\n共享：方法区（运行时常量池）、Java堆（对象及数组在此创建）\n\n我们不难发现，由线程独占的区域不需要内存回收机制：从时间上来说，它们与线程“同生共死”;从空间上来看，PC所占空间大小是恒定不变的。而栈则由于其自身的LIFO特性，也无需额外的内存清理工作。\n而线程共享的区域，包括方法区和Java堆则是GC所要考虑的。之前说过，Java堆是垃圾收集器的主要战场，在堆中创建对象十分频繁，名副其实的垃圾堆。那么我们如何识别方法区和堆上的所谓垃圾呢？\n所谓垃圾就是没用的东西。在Java中，数据都是以对象形式组织起来的，垃圾即是无法被访问到的对象。所以说判断一个对象是不是垃圾，可以看它被引用的数量。哪怕在一处被引用，它也是不可回收的。很自然地，我们可以为每一个对象设置一个计数器，每被引用一次计数器加一，反之减一。当引用数为0的时候，说明没有任何途径可以访问到这个对象，此时可以回收该对象。这就是引用计数法。\n但这个方法虽然简单，可是却有一些问题。看下面一段代码：\n\n\n首先，两个类A和B，其中A中有一个B类型的字段bRef，或者说可以指向B类型的引用；同样地，B中有一个A类型的字段aRef。接下来我们实例化两个对象a、b，并且将实例a的bRef指向实例b，而将实例b的aRef指向实例a。随后将a、b均设为null。现在，我们再也无法从外部访问到类型A、B的两个实例了，按说这两个实例都可以被标记为垃圾被回收。但按照引用计数法，由于它们俩各自持有对对方的引用，因此他们的引用计数均为1，因此无法被回收。这就是引用计数法无法解决的“循环引用问题”。\n看来得想想别的办法。问题出在哪里呢？我们发现引用计数法对所有的引用都一视同仁，但好像并不是所有的引用都有效。那么什么样的引用才是有效的引用呢？我们定义一组这样的活跃引用：\n\n栈（栈帧中的本地变量表）中的引用\n方法区中引用\n\n我们可以发现它们一个共同的特点：在Java堆的外面。由这样一组引用所直接指向的对象所组成的集合就叫做GCRoots。简而言之，GCRoot就是在堆外被直接引用的对象。\n\n\n以GCRoots为起点，继续寻找它们所引用的对象，以此类推，这样顺着引用链搜索便可以找到堆中其他的可用对象，这叫做root tracing。而剩下的对象就是不可用的，可以被回收。\n以上所述为Java堆中对象的标记，那么方法区又是怎样的呢？方法区里主要存储的是类型信息。而一个类想要被回收，则它必须满足：\n\n该类的所有实例都已被回收\n加载该类的ClassLoader已被回收\n该类对应的Class对象在任何地方被引用，且在任何地方都无法通过反射访问该类的方法。\n\n此时，一个类可以被回收。可以说回收条件是相当苛刻的。所以方法区的回收效益并不高。其实JVM规范并没有对方法区的垃圾收集行为做强制性规定，虚拟机实现甚至可以选择在方法区内不进行垃圾收集。但是，作为一款优秀的JVM方法区的回收也是必须的。\n如何回收？已经知道回收哪些内存区域了，通过什么方式回收呢？基本思想主要有以下三种：\n\n标记-清除算法\n标记-整理算法\n复制算法\n\n标记清除算法标记-清除算法分为两个阶段：第一个阶段标记出所有需要回收的对象，具体做法在之前已经讲到。第二阶段，回收被标记对象的内存区域。\n\n\n这个算法简洁明了，但缺点也很明显：经过回收之后的内存区域碎片化严重，存在大量离散的空间。这很不利于后续的内存分配。\n标记整理算法标记-整理算法在标记之后会将存活的对象向一端移动，然后直接清除边界以外的空间。这样做的好处很明显：GC后的内存是连续规整的，有利于后续的内存分配。\n\n\n复制算法接下来是复制算法。使用复制算法时，需要将内存等分为两个区域。每次只在其中一个区域内分配。当该空间用完时，先标记对象，然后将存活对象依次复制到另一个区域里，形成连续的存活对象区域。后续的内存分配只在该区域内进行，直至空间用完，触发下一次GC,如此周而复始。\n\n\n相较标记-清除算法，复制算法的一个显著优点是回收后的内存空间十分规整，无论是在使用的空间还是未使用的空间都是连续分布，这样后续的内存分配也更加快速。当然缺点也很明显：空间利用率不高。\n分代收集在介绍完以上三种基本的垃圾收集思路后，再来看一看分代收集算法。之所以提出分代收集，一是上述的思想每一种都不能称之为完美，各自的优点和局限都比较突出。二是经过研究发现，若以存活时间为标准将对象分代，那么不同代际的对象在存活率上确实有显著差异。比如：IBM的研究表明，新生代中的对象98%都是“朝生夕死“，也就是说存活率很低。\n\n\n结合以上两点，我们可以在不同年龄的对象上使用不同的垃圾收集算法，扬长避短，获得最好的收集效果。\n分代算法一般根据对象存活的时间，即所经历的GC轮次，将对象分为新生代和老年代两种。因此对于新生代可以使用复制算法：因为留下来的并不多，所以复制的效率并不会太差。而成长为老年代的对象一般来说存活率都比较高，因此可以使用标记-整理算法：因为大部分对象都会存活下来，每次GC后，存活对象间不会出现太多的空闲区域需要压缩整理，因此整理所花费的代价也不会太高。\n后记方法论讲完了，在本系列的最后一篇，我们将来看一看HotSpot虚拟机如何完成高效实现。\n","thumbnail":"/2019/12/15/jvm-memory-management-p2/troye.jpg","plink":"http://xray.kim/2019/12/15/jvm-memory-management-p2/"},{"title":"JVM内存管理(一)","date":"2019-12-08T19:44:01.000Z","updated":"2021-05-10T21:08:59.233Z","content":"前言该系列源自一个月前的技术分享讲稿，稍作整理后记录于此。系列分为3篇，分别是：内存分配、内存回收以及内存管理技术在HotSpot上的具体实现。本篇先来聊一聊JVM中内存的分配。\n从虚拟内存说起说起内存，可能大家的第一反映是这个：\n\n\n从硬件的角度来看，内存就是一块有固定容量的存储体,与该硬件直接打交道的是我们的操作系统。我们知道在操作系统中，进程都是共享CPU和内存资源的。现代操作系统为了更有效的管理内存,广泛使用了虚拟内存技术。\n在提出虚拟内存之前，内存是这样访问的: \n\n\n我们把一块大的内存分成很多一样大的单元，给他们依次编上号，也就是内存的物理地址。进程要访问哪个单元的数据时候，就要指明物理地址。\n各个进程直接访问物理地址，这就有很大的随意性，安全性得不到保障：你在内存上存得数据可能随时被别人改写了。写个程序还要搞清楚内存硬件得结构，十分不便。于是虚拟内存技术应运而生：既然各个进程直接访问物理内存不好，那就让操作系统接管物理内存的访问，而进程访问时，先告诉操作系统一个地址，然后由操作系统代为访问。与物理地址相对应，进程所用的地址就是逻辑地址。\n我们可以看着张示意图，cpu在执行某个进程的代码，当进程访问一个内存地址时，这个地址其实是经过了内存管理单元的转换，再变成物理地址。\n\n\n有了这一层转换，那这样我就可以做些有趣的事情。\n比如我们内存条是1G的, 这时某个进程需要4G的内存,那么操作系统可以为其映射出4G的空间。具体是这样：虚拟内存将主存看成是磁盘的高速缓存，应用在未运行之前,只是存储在磁盘上二进制文件。当你双击鼠标启动一个应用时，操作系统就为这个应创建了一个进程。这时并不需要把应用的全部代码和数据都加载进内存，而是用到哪些加载哪些。虽然你的进程需要访问4G的空间，但并不是每时每刻都需要用到全部的数据。所以咱们就拆东墙补西墙：内存空间不够时，那就把暂时不用的换出到磁盘，腾出新的空间来载入新的数据。空间不够，时间来凑：通过用时间换空间的方式达到放大内存的效果。\n因此，虚拟内存可以为每个进程提供了一个假象：每个进程都在独占地使用主存,每个进程看到的内存都是一样的,这称之为虚拟地址空间。这样，操作系统就可以为每个进程提供独立的地址空间,简化了内存管理机制。简单点来看就是每个进程都认为自己独占该主存。\n\n\n就像一栋楼被分成许多个房间,每个房间都是独立的，每个户主拿到一个房间，都可以从零开始自助装修。另外,在未征得其他户主的同意之前,你是无法进入其他房间的，这样大大增加了安全性。\n现在我们明白在操作系统中所谈的内存其实是虚拟内存。那么虚拟地址空间的布局是如何的呢? 以Linux系统为例，来看一下它的进程空间地址的布局。\nJVM的内存结构现在来到了进程这一层级。我们知道,每个JVM都运行在一个单独的进程当中，JVM本质上也是一个程序，只不过它又有着类似操作系统的特性，有着自己的内存模型和内存结构。当一个JVM实例开始运行时，此时在Linux进程中,其内存布局如图中所示。\n\n\n从下到上，内存地址由低到高。内核空间在高位，这里映射的是操作系统内核的代码。用户空间在低位，我们看到，从低到高依次为代码数据区、堆区、共享库和用户栈。\nJVM进程对内存空间进行了进一步划分。\n\n\n总的来说，主要就是栈和堆两个部分。基于进程栈，JVM实现了自己的方法执行栈而对于进程的堆，JVM把它划分为：方法区和Java堆。方法区就是Java程序的代码数据区，Java堆才是Java程序真正使用的堆区。右边这一块就是JVM的运行时数据区，也就是它的内存结构。下面这张图展示了它的详细结构。\n\n\n主要分为这几块：虚拟机栈、本地方法栈、PC寄存器以及方法区和Java堆。其中右边两块是JVM中所有线程所共享的，而左边则是各个线程私有的。也就是每个线程都有自己的一套栈和PC寄存器。下面一一介绍。\nPC寄存器PC寄存器就跟CPU中的PC寄存器类似，用来存储下一条指令的地址。只不过这里的指令是字节码。我们知道Java源码编译成字节码后再交由JVM执行的。\nJVM栈Java虚拟机栈，这是用来执行Java方法的。每调用一个方法，一个对应栈帧就会被创建并入栈。一个方法的执行过程就是其栈帧从入栈到出栈的过程。栈帧中主要存储：局部变量表、操作数栈、动态链接以及方法出口等信息。局部变量表存放方法参数和方法内定义的局部变量；操作数栈用于存放方法体中指令的操作数；每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用；方法返回地址保证方法正常返回时能够继续正常执行。\n\n\n虚拟机栈也是线程独有的，每创建一个线程，其相应的栈也会被创建；相应的，一个线程在销毁后，其对应的栈也会被销毁。\n本地方法栈除了虚拟机栈，还有一个本地方法栈。这个栈是用来执行非Java方法的，主要是C或者C++写成的方法。大家可能觉得奇怪，你一个JVM怎么还要执行非Java方法呢？这主要是因为Java运行于虚拟机之上，与外界的交互没有那么方便。比如操纵JVM线程，因为JVM线程也是对操作系统线程的映射，Java不好直接和操作系统交流那就只有求助于本地方法了。\n方法区方法区就是Java程序的代码区，这里主要存放类的信息。在方法区中由一块很重要的区域便是运行时常量池。运行时常量池主要存放的字面量和符号引用。符号引用简单来说就像门牌号一样，用来标识类、以及类中的字段、方法。\n什么是运行时常量池呢？首先我们要搞清楚什么是常量池。常量池是Class文件的重要组成部分。我们知道一个类对应一个Class文件，这个文件就是对类的描述，比如这个类的类名、有哪些字段、有什么方法等等。而像类名、字段名、方法名这样的信息就存储在常量池中。\n看下面一个例子：我们定义一个Hello类，它有两个方法：foo和bar，其中foo调用了bar。我们使用javac进行编译并使用javap反编译Class文件。\n\n\n这里是class文件中存储的foo的定义，当然这个结果经过了javap的重新编排便于阅读。我们关注foo的code属性部分，它包含3条字节码。其中第二条是对bar的调用。可以看到invokevirtual指令的操作数是一个编号，指向就是常量池。常量池就像class文件中的仓库一样，class文件的其他项目都会引用它的内容。而在class文件定义的类被加载后，其中的常量池字段被存储在运行时常量池中。方法区是所有线程所共享的。\nJava堆这里就是对象所在的地方。根据JVM规范，对象和数组都在堆上分配。\nJava的堆区和进程上的堆却又很大的区别:使用进程上的堆，比如在调用C程序的malloc函数时，会引起一次系统级的调用；在使用free函数释放内存时,同样也会引起一次系统级的调用,但是JVM中堆区并非如此：JVM一次性向系统申请一块连续的内存区域,作为Java程序的堆。当Java程序使用new申请内存时，JVM会根据需要在这段内存区域中为其分配，而不需要一次系统级别的调用。相比系统级别的调用，JVM实现内存管理成本更低。\nJava堆是进行垃圾收集的主要区域，详见后续文章。\n对象的创建下面说说对象的创建，在简简单单的一个关键字new背后发生了什么呢？主要分为以下阶段：\n\n类加载检查\n内存分配\n内存空间初始化\n对象信息设置\n构造方法执行\n\n当你要new一个对象时，首先会检查这个类有没有被加载。具体来说根据指令的参数检查能否在常量池定位到这个类的符号引用。如果发现这个类还没有被加载，则进行类加载过程。\n接下来为对象进行内存的分配，即划分出一块大小已知的连续内存。这里分为两种情况：一是，当空闲内存是连续规整的，那么我可以设置一个指针，指针的一边是使用中的内存，另一边是空闲内存。分配时把指针向空闲一边移动一段与对象大小相等的距离即可。这种分配方式叫做“指针碰撞”。二是，假如内存不是连续规整的，那么虚拟机就要维护一个列表，记录哪些内存区域是可用的，分配时从列表中选取合适的内存区域进行分配。这叫做“空闲列表”。我们可以注意到，连续规整的内存可以让内存的分配更加简单快速。\n接下来将分配到的内存空间全部初始化为零，并设置对象头中的信息，比如：对象类型指针、hashCode等。最后执行为对象的构造方法，进行用户自定义的初始化。至此你们要的对象在堆中诞生了。\n后记本篇从自底向上的视角简要介绍了JVM的内存布局及分配，下一篇咱们继续聊聊JVM内存管理中的内存回收技术。\n","thumbnail":"/2019/12/08/jvm-memory-management-p1/taylor.jpg","plink":"http://xray.kim/2019/12/08/jvm-memory-management-p1/"},{"title":"Hello World","date":"2019-10-01T16:32:23.000Z","updated":"2021-05-10T21:08:59.233Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","plink":"http://xray.kim/2019/10/01/hello-world/"}]